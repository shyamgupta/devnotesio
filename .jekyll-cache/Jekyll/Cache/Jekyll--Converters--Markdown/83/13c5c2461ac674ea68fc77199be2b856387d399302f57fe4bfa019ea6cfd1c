I"è<h2 id="classpath-and-jar-files">Classpath and JAR Files</h2>

<p>The concept of a path should be familiar to anyone who has worked on a DOS or Unix platform. It‚Äôs an environment variable that provides an application with a list of places to look for some resource. The most common example is a path for executable programs. The Java CLASSPATH environment variable, similarly, is a list of locations that can be searched for packages containing Java class files. Both the Java interpreter and the Java compiler use CLASSPATH when searching for packages and classes on the local host. A location on the class path can be a directory name or the name of a class archive file.</p>

<p>A JAR (<strong>J</strong>ava <strong>Ar</strong>chive) file is a bundle of compiled Java code.  Java supports archives of class files in its own Java archive ( JAR) format, and in the conventional ZIP format. JAR and ZIP are really the same format, but JAR archives include extra files that describe each archive‚Äôs contents. JAR files are created with the SDK‚Äôs jar utility. The archive format enables large groups of classes to be distributed in a single file; the Java interpreter automatically extracts individual class files from an archive, as needed. Once the JAR file is downloaded, all we need to do is to add it to the classpath - we can then start interacting with the classes and objects defined in the JAR.</p>

<h2 id="before-spring">Before Spring</h2>

<p>Before the Spring revolution, enterprise applications were generally written using the J2EE standards. In theory, you could deploy your application on any J2EE application server, on any platform. Running your application on an application server has several benefits, the application server offers you services, such as transaction management, messaging, mailing, a directory interface etc. Any J2EE compliant code can make use of these services, as long as the code is written against the interfaces defined in the J2EE specifications.</p>

<p>Unfortunately, there were a few problems with these standards. First of all, the usage of these standards was too complex. Writing a component (EJB: Enterprise Java Bean) required you to write a set of xml files (deployment descriptors), home interfaces, remote/local interfaces, etc. Even worse, 50% of the deployment descriptors were vendor specific, so ‚Äòtransparently migrating an application from vendor A to B‚Äô was suddenly not so transparent anymore.</p>

<p>Secondly, there was the ‚Äòlook-up‚Äô problem. When a component requires another component, the components itself was responsible for looking up the components it depends upon. Unfortunately, this look-up happens by name, so the name of the dependency was hardcoded in your component.</p>

<p>Last but not least, in a lot of cases, some components did not need all the services the application server provided, but since there was no other API to build components, all your components became heavy weight, bloating your application.</p>

<h2 id="the-pojo-revolution">The POJO Revolution</h2>

<p>Coding against the J2EE standards was very cumbersome, you needed to comply to several seemingly arbitrary rules, and it forced you to write code that was not so Object Oriented as one would want to. More and more developers wanted to write just Plain Old Java Objects (POJO‚Äôs), without the J2EE standards overhead.</p>

<p>Spring allows you to do programming with very simple non-Spring classes, which means there is no need to implement Spring-specific classes or interfaces, so all classes in the Spring-based application are simply POJOs. That means you can compile and run these files without dependency on Spring libraries.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span><span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(){</span>
		<span class="k">return</span> <span class="s">"Hello World"</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
The preceding class is a simple POJO class with no special indication or implementation related to the framework to make it a Spring component. So this class could function equally well in a Spring application as it could in a non-Spring application.</p>

<p>The only problem with POJO‚Äôs is that with J2EE (as it existed then) you cannot benefit from the services provided by the container, such as transaction management, remoting, etc. This is where the Spring Framework comes in. This framework brings a lightweight container where your POJO‚Äôs live in. You don‚Äôt have to support services you don‚Äôt need, this also means no unneeded configuration. You don‚Äôt have to adhere to some programming model, you can just use POJO‚Äôs and declaratively specify what services you want to use.</p>

<h2 id="spring-framework">Spring Framework</h2>

<p>Spring is a framework that integrates all kinds of Java technologies/API‚Äôs and makes it possible to use them with simple POJO‚Äôs. It provides a nice and elegant way to use existing technologies (such as EJB, Hibernate, JDO, Toplink, JMS, etc). This is accomplished by several support classes and ‚Äòtemplates‚Äô.</p>

<p>For each supported technology there is a module which consists of helper classes to help you implement a certain layer or aspect of your application. The core of Spring, upon which all other modules depend, is the Inversion of Control and Aspect-Oriented programming module. It is these two programming models which are the driving force behind Spring.</p>

<h4 id="inversion-of-control-ioc">Inversion of Control (IoC)</h4>
<p>When developing an application, you always have dependencies between and on components, services, classes etc. Without Inversion of Control you would ‚Äòwire‚Äô these together on the spot where you would need the dependency. The disadvantage of this is that when you would like to use a different implementation of your dependency, you are forced to change your code. With Spring, wiring of these dependencies is taken out of the code, and an external party manages the wiring, namely the container. Hence the name inversion of control, you let something from the outside control how your dependencies are wired together. We speak of dependency injection because the container ‚Äòinjects‚Äô the necessary dependencies instead of letting the developer manage them.</p>

<p>Spring provides an object factory - our application can talk to Spring requesting for a new object. Based on the configuration file or annotation, Spring will give us the appropriate implementation. This makes our application configurable.</p>

<h4 id="aspect-oriented-programming-aop">Aspect Oriented Programming (AOP)</h4>
<p>In most applications there are concerns that ‚Äòcut‚Äô across different abstraction layers, the typical example is logging. Cross cutting concerns are concerns that cut across multiple application modules. These concerns often cannot be cleanly decomposed from the rest of the system in both the design and implementation, and can result in either scattering (code duplication), tangling (significant dependencies between systems), or both. Aspect oriented programming help us with the separation of cross cutting concerns and decouple them from the core application modules.</p>

<p>So basically, AOP helps us create application wide services like logging, security, and you apply them in a declarative fashion to the classes that need these services.</p>

<h2 id="modules-and-ioc-container">Modules and IoC Container</h2>
<p>The Spring Framework consists of features organized into about 20 modules. These modules are grouped into Core Container, Data Access/Integration, Web, AOP (Aspect Oriented Programming), Instrumentation, and Test, as shown in the following diagram.</p>

<p><img src="../assets/img/iocContainer.png" alt="IoC Container" /></p>

:ET