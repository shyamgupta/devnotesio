I" <h2 id="classpath-and-jar-files">Classpath and JAR Files</h2>

<p>The concept of a path should be familiar to anyone who has worked on a DOS or Unix platform. It’s an environment variable that provides an application with a list of places to look for some resource. The most common example is a path for executable programs. The Java CLASSPATH environment variable, similarly, is a list of locations that can be searched for packages containing Java class files. Both the Java interpreter and the Java compiler use CLASSPATH when searching for packages and classes on the local host. A location on the class path can be a directory name or the name of a class archive file.</p>

<p>A JAR (<strong>J</strong>ava <strong>Ar</strong>chive) file is a bundle of compiled Java code.  Java supports archives of class files in its own Java archive ( JAR) format, and in the conventional ZIP format. JAR and ZIP are really the same format, but JAR archives include extra files that describe each archive’s contents. JAR files are created with the SDK’s jar utility. The archive format enables large groups of classes to be distributed in a single file; the Java interpreter automatically extracts individual class files from an archive, as needed. Once the JAR file is downloaded, all we need to do is to add it to the classpath - we can then start interacting with the classes and objects defined in the JAR.</p>

<h2 id="gradle">Gradle</h2>

<p>Gradle is a general purpose build management system that supports automatic download and configuration of dependencies or other libraries (in addition to compiling and executing your code, testing and building your project for deployment). A project using Gradle describes its build via a <code class="highlighter-rouge">build.gradle</code> file. This file is located in the root folder of the project and we will use it to list the libraries we want to incorporate into our project. After this is done, with the click of a button in our IDE, Gradle will download all the JAR files for the libraries we listed, including their dependencies.</p>

<p>Below is a sample <code class="highlighter-rouge">build.gradle</code> file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>repositories {
	mavenCentral()
}
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><strong>repositories</strong>: The repositories block allows us to define one or more locations where Gradle should look for the libraries we list. We will be using Maven Central which is one of the largest public dependency repositories.</li>
  <li><strong>dependencies</strong>: This is the block where we will be listing the libraries we need. Whenever we update this block, we can refresh the projects jar files through the Gradle tool window available in most IDEs. Below is the syntax to list a library we need - the <code class="highlighter-rouge">compile</code> keyword tells Gradle that we need the dependency at compile time, i.e. it’s required for our source code to compile:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compile 'groupId:artifactId:version'
//Example
compile 'org.springframework:spring-webmvc:5.2.2.RELEASE'
</code></pre></div></div>

<p><br />
Gradle simplifies dependency management - for example the spring-mvc library has 6 dependencies and each of these have their own dependencies &amp; so on. Installing these dependencies manually is not practical, and that’s where Gradle comes to the rescue.</p>

<h2 id="gradle-for-spring-boot-development">Gradle for Spring Boot Development</h2>

<ul>
  <li><strong>apply plugins</strong>: In Gradle, plugins are extensions of Gradle and add functionalities to Gradle’s built-in features. The java plugin allows Gradle to compile different source sets, compiling main code, compile and run test code separately. The java plugin expects our main application code in the <code class="highlighter-rouge">/src/main/java</code> directory.</li>
  <li><strong>dependencies</strong>: Spring Boot allows us to create a standalone, runnable Spring application that has an embedded Tomcat web server. The Spring Boot dependency we’ve added includes the spring-mvc dependency.</li>
  <li><strong>plugins</strong>: Spring Boot has a Gradle plugin that can deploy a Spring application with a web server. However, this plugin is not built into Gradle and we need to add it to the buildscript. Additionally, the <code class="highlighter-rouge">org.springframework.boot</code> entry under apply plugin will allow us to run a Gradle task that will compile and deploy our application in an embedded web server.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins {
    id 'java'
    id 'org.springframework.boot' version '2.2.2.RELEASE'
}

group 'org.teamtreehouse'
version '1.0-SNAPSHOT'


apply plugin: 'java'
apply plugin: 'org.springframework.boot'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    compile 'org.springframework.boot:spring-boot-starter-web:2.2.2.RELEASE'

}
</code></pre></div></div>
<p><br /></p>
<h2 id="configure-your-application">Configure Your Application</h2>

<ol>
  <li>Create a base package under which we will put all of our Java code. Under <code class="highlighter-rouge">/src/main/java</code> create a new package and call it <code class="highlighter-rouge">com.teamtreehouse.giflib</code> for example.</li>
  <li>Within the package we created above, create Java class named <code class="highlighter-rouge">AppConfig</code> (it could be any name).</li>
  <li>Below is the code in our AppConfig file - it has the main() method. Within the main() method, we are calling the <code class="highlighter-rouge">SpringApplication.run()</code> method in the Spring Boot library that will run our application, thereby creating a new application context.</li>
  <li>Finally, in order for Spring to be auto configured, we have added the <code class="highlighter-rouge">@EnableAutoConfiguration</code> annotation. This annotation tells Spring Boot to “guess” how you want to configure Spring, based on the jar dependencies that you have added. Since spring-boot-starter-web dependency added to classpath leads to configure Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly.</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">teamtreehouse</span><span class="o">.</span><span class="na">giflib</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>

<span class="nd">@EnableAutoConfiguration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
Above steps are all we need to configure a Spring application which is deployable to a web server. When you run the application and visit <code class="highlighter-rouge">http://localhost:8080/</code>, you should see the Whitelabel Error Page.</p>

:ET