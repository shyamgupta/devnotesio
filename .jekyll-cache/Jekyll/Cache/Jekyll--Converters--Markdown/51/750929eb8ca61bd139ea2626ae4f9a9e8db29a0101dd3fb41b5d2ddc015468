I"À(<h2 id="introduction">Introduction</h2>
<p>Spring Data comes with a common programming model for persisting data in various types of database engine, ranging from traditional relational databases (SQL databases) to various types of NoSQL database engine, such as document databases (for example, MongoDB), key-value databases (for example, Redis), and graph databases (for example, Neo4J).</p>

<p>The two core concepts of the programming model in Spring Data are entities and repositories. Entities and repositories generalize how data is stored and accessed from the various types of database.</p>

<ul>
  <li><strong>Entity</strong>: An entity describes the data that will be stored by Spring Data. Entity classes are, in general, annotated with a mix of generic Spring Data annotations and annotations that are specific to each database technology. For example, an entity that will be stored in a relational database can be annotated with JPA annotations such as @Entity.</li>
  <li><strong>Repository</strong>: Repositories are used to store and access data from different types of database. In its most basic form, a repository can be declared as a Java interface, ` Repository&lt;T,ID&gt;` where T is the type being stored and ID is a primary key type -  Spring Data will generate its implementation on the fly.  Spring Data also comes with some base Java interfaces, for example, CrudRepository, to make the definition of a repository even simpler. The base interface, CrudRepository, provides us with standard methods for create, read, update, and delete operations. If we want to use the repository, we can simply inject it (using @Autowired) and then start to use it.</li>
</ul>

<h2 id="object-relational-mapping-orm-and-java-persistence-api-jpa">Object-Relational Mapping (ORM) and Java Persistence API (JPA)</h2>
<p>Object-Relational Mapping (ORM) is a technique that allows you to fetch and manipulate from a database by using an object-oriented programming paradigm. ORM is really nice for programmers because it relies on object-oriented concepts, not on database structure. It also makes development much faster and reduces the amount of source code. ORM is mostly independent of the databases and developers don‚Äôt have to worry about vendor-specific SQL statements.</p>

<p>Java Persistent API (JPA) provides object-relational mapping for Java developers. The JPA entity is a Java class that presents the structure of a database table. The fields of an entity class present the columns of the database tables.</p>

<p>Hibernate is the most popular Java-based JPA implementation, and it is used in Spring Boot as a default. It is a mature product and it is widely used in large-scale applications.</p>

<h2 id="map-a-database-table-to-a-java-class">Map a Database Table to a Java Class</h2>
<p>Let‚Äôs start with a simple example, where we map one database table to one JPA entity: below we have a STUDENT table with 4 columns:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">student_id</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="n">student_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
<span class="n">student_fulltime</span> <span class="nb">TINYINT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">student_age</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<p>Below we have a Java Student class with 4 attributes that represents the above database table.</p>
<ul>
  <li>The class must be annotated with <code class="highlighter-rouge">@Entity</code>.</li>
  <li>Entities must have a unique identfier annotated with <code class="highlighter-rouge">@Id</code>. JPA will generate the id when persisted, for this reason we don‚Äôt include student_id in the constructor. The id field is used to hold the database identity of each stored entity‚Äîthe primary key when using a relational database. Here, we are delegating the responsibility to generate unique values of the identity field to Spring Data.</li>
  <li><code class="highlighter-rouge">@Column</code> maps the class atributes to table columns.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"STUDENT"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="o">{</span>
	<span class="nd">@Id</span>
	<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span><span class="o">=</span><span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"student_id"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Integer</span> <span class="n">student</span> <span class="nc">Id</span><span class="o">;</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"student_name"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"student_fulltime"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">fullTime</span><span class="o">;</span>

	<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"student_age"</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Student</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">fullTime</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">fullTime</span> <span class="o">=</span> <span class="n">fullTime</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">//getters and setters logic here</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p>Now that we have define dthe object to relational mapping metadata, all of our database related coding can stay in the logical world because JPA will take care of the physical world for us.</p>

<h2 id="repository">Repository</h2>

<p>The most effective way for our application to interact with this table is using the full force of Spring Data JPA. With Spring Data, we define a repository interface for each entity in the application. <strong><em>A repository is a ‚Äúdata access‚Äù pattern that contains methods for performing CRUD operations</em></strong>. To do this, we create a repository (a Java interface) that provides CRUD operations for Student objects by extending the <code class="highlighter-rouge">CrudRepository&lt;Class_Name, ID_Type&gt;</code> interface:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">StudentRepository</span> <span class="kd">extends</span> <span class="nc">CrudRepository</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>
<p><br /></p>

<p>The preceding interface might appear empty, but the inherited methods inside CrudRepository provide the core CRUD operations we need. The interface is generically typed to match up with the domain class and the ID‚Äôs field type.</p>

<p>With this code in place, when Spring Boot creates an application context, Spring Data JPA will scan and discover our repository definition. Then it will automatically generate a concrete proxy that implements this interface. This saves us the labor of writing all these queries. Below are some useful methods that CrudRepository includes:</p>

<p>By inheriting from CrudRepository, we can call many methods without the need to implement them ourself. We can also define our own methods. These method names should use special keywords such as ‚Äúfind‚Äù, ‚Äúorder‚Äù with the name of the variables. Spring Data JPA developers have tried to take into account the majority of possible options that you might need. In our example for the Student entity, <code class="highlighter-rouge">findByStudentName(String student_name)</code> method returns all entries from the table with the specified student_name.</p>

<p><strong>Create Method</strong></p>
<ul>
  <li>Class_Name save(Class_Name object_variable)</li>
</ul>

<p><strong>Read Methods</strong></p>
<ul>
  <li>Optional<Class_Name> findById(ID id)</Class_Name></li>
  <li>boolean existsById(ID id)</li>
  <li>Iterable<Class_Name> findAll()</Class_Name></li>
  <li>findOne(ID id)</li>
  <li>Iterable<Class_Name> findAllById(Iterable<ID> iterable)</ID></Class_Name></li>
  <li>long count()</li>
</ul>

<p><strong>Update Method</strong></p>
<ul>
  <li>Iterable<Class_Name> saveAll(Iterable<Class_Name> iterable)</Class_Name></Class_Name></li>
</ul>

<p><strong>Delete Methods</strong></p>
<ul>
  <li>void deleteById(ID id)</li>
  <li>void delete (Class_Name object_Name)</li>
  <li>void deleteAll(Iterable<Class_Name> iterable)</Class_Name></li>
  <li>void deleteAll()</li>
</ul>

:ET