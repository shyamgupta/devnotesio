I"(#<h2 id="introduction">Introduction</h2>
<p>GraphQL is a query language for API’s or a syntax that describes how to ask for data and is generally used to load data from a server to a client. It is an alternative to REST and allows us to request data in the exact shape we want, and also make changes to our data. GraphQL is composed of two main parts:</p>
<ul>
  <li>GraphQL Query Language (which is what we will be focusing on) is used to request data</li>
  <li>Framework which processes the queries.</li>
</ul>

<p>GraphQL benefits:</p>
<ul>
  <li>Allows us to specify the format in which we want our data</li>
  <li>Self documenting API, i.e. by looking at the API’s schema, what the data coming out of if will look like, which queries will work &amp; which one’s wont. The schema looks a lot like JSON.</li>
  <li>Ability to fetch deeply nested data in a single request.</li>
  <li>Ability to mount GraphQL in front of any existing API.</li>
  <li>Super flexible - for developing new API’s, we can start with scratch where our GraphQL server that communicates with our database. However, if we alreday have an API that communicates with the database, you can bolt GraphQL in front of that API.</li>
  <li>GraphQL does not care where the data comes from, making it useful for a wide variety of applications</li>
  <li>GraphQL is language agnostic, as its just a query language.</li>
</ul>

<p>With REST, the client hits an endpoint and gets a massive JSON object as the response. With GraphQL, instead of hitting a URL endpoint, GraphQL lets you write a query to request exactly the data we want and receive just that in the response.</p>

<h2 id="rest-vs-graphql">REST vs. GraphQL</h2>
<p>Let’s say we want to retrieve information related to authors: name, courses authored, rating, most recent (3) topics covered. With the REST approach, we will need to create the following endpoints:</p>

<ul>
  <li>/author/<id> : Provides the author information for a given id. This may also return additional fields we may not need.</id></li>
  <li>/author/<id>/courses</id></li>
  <li>/author/<id>/rating</id></li>
  <li>/author/<id>/topics: Will retrieve all topics instead of 3 most recent topics we are interested in.</id></li>
</ul>

<p>Instead of having multiple endpoints that return fixed data structures, GraphQL APIs typically only expose a single endpoint.  This works because the structure of the data that’s returned is not  fixed. Instead, it’s completely flexible and lets the client decide what data is actually needed. That means that the client needs to send more information to the server to express its data needs - this information is called a query.</p>

<p>With GraphQL, we can accomplish the above in a single request, by composing a query - the query (shown below) will ask for exactly what we need and we will receive the JSON object with the just the information requested. Note that we are only requesting the information we are interested in, for example the author name, course title etc - this means that the client does not have to filter the results (as with REST) to get what was requested, and its fast. All of this is done in just one query instead of multiple round trips.</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">query</span><span class="p">{</span><span class="w">
    </span><span class="n">author</span><span class="p">(</span><span class="n">id</span><span class="p">:</span><span class="mi">2000</span><span class="p">){</span><span class="w">
        </span><span class="n">name</span><span class="w">
        </span><span class="n">courses</span><span class="p">{</span><span class="w">
            </span><span class="n">title</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="n">rating</span><span class="w">
        </span><span class="n">topics</span><span class="p">(</span><span class="n">last</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">){</span><span class="w">
            </span><span class="n">name</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p><br /></p>

<table class="table table-striped table-bordered table-hover table-responsive-sm">
	<thead class="thead-dark">
		<tr>
			<th>REST</th>
			<th>GraphQL</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Multiple round trips to collect the information from multiple sources.</td>
			<td>One single request to collect the information by using the GraphQL query.</td>
		</tr>
		<tr>
			<td>
				Over fetching &amp; under fetching of data resources. We end up with data we don't need (as there's no way to filter out the request) or if we want something specific which is not part of the endpoint resulting in multiple round trips.
			</td>
			<td>
				You get what you asked for by using tailor made queries.
			</td>
		</tr>
		<tr>
			<td>Front end teams rely heavily on backend teams to deliver APIs - the front end development could be stalled until the API is ready.</td>
			<td>Frontend and backend teams can work independently, where the front end team can work on mock APIs, until the backend API is available.</td>
		</tr>
		<tr>
			<td>Caching is built into HTTP.</td>
			<td>Does not use HTTP for caching and its upto the developer to implement caching.</td>
		</tr>
	</tbody>
</table>

<h2 id="graphql-ecosystem-and-tools">GraphQL Ecosystem and Tools</h2>
<ul>
  <li><strong>GraphQL Clients</strong>:
    <ul>
      <li>Handles sending queries to the server, and receiving the JSON from the server.</li>
      <li>Integrates with our view and updates the UI.</li>
      <li>Handles caching the query results.</li>
      <li>Error handling and schema validation</li>
      <li>Some clients also provide local state management, caching, pagination</li>
      <li>Popular GraphQL clients: Apollo (very popular), Relay (only for React)</li>
    </ul>
  </li>
  <li><strong>GraphQL Server</strong>:
    <ul>
      <li>Primary purpose: Receive the query from the client and responds back.</li>
      <li>We write Schema and Resolver functions on the GraphQL server. Resolver functions resolve a value for a type/field in the GraphQL schema. Resolvers can return scalars or objects.</li>
      <li>GraphQL Execution Engine parses the query from the client, validates the schema and returns the JSON response back. It also executes resolvers for each field.</li>
      <li>Popular GraphQL server libraries: Apollo Server (very popular), Express GraphQL, GraphQL Yoga</li>
    </ul>
  </li>
  <li><strong>Database to GraphQL Server</strong>:  Prisma is a popular database to GraphQL server option, and it sits between the GraphQL server and the actual database. It bridges the gap between the database and resolvers, supports both SQL and NoSQL databases. It replaces the traditional ORM - it provides a data access layer that makes it easy for API servers to talk to database through Prisma.</li>
  <li><strong>GraphQL Tools</strong>:
    <ul>
      <li>GraphiQL: Its an in-browser IDE for writing, validating and testing GraphQL queries. Supports live syntax and validation errors. GraphiQL is a simple web app that is able to communicate with any GraphQL Server and execute queries and mutations against it.</li>
      <li>GraphQL Voyager: Represents a GraphQL API as an interactive graph. Also used during design of data model.</li>
      <li>GraphQL Faker: Mock your API with realistic data from faker.js</li>
      <li>GraphQL Visual Editor: Create schemas by joining visual blocks and the Visual Editor will transform them to actual code.</li>
    </ul>
  </li>
</ul>

<h2 id="graphql-terminology">GraphQL Terminology</h2>
<ul>
  <li><strong>Queries</strong>: Queries specify the data we want to fetch from a GraphQL server.</li>
  <li><strong>Fields</strong>: They are properties that make up the shape of our objects. Using fields, we can include or exclude properties of an object to craft a tailored response.</li>
  <li><strong>Types</strong>: Types are collection of fields that make up a queryable object.</li>
  <li><strong>Schema</strong>: Schema defines the server’s API, allowing clients to know which operations can be performed by the server.</li>
  <li><strong>Resolvers</strong>: Let’s say our API is able to run two query operations, i.e one to retrieve an array of books and another to retrieve a book based on its id. The next step for us is to define how these queries get resolved so that the right fields are returned to the client. The way to do this is by defining a resolver function for every field in the schema.</li>
</ul>

<p>For example, if I’ve  movie and studio types, the movie field will have fields like name, release data, and studio type will have fields like an ID, name etc.</p>

:ET