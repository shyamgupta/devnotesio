I"Ï<h2 id="classpath-and-jar-files">Classpath and JAR Files</h2>

<p>The concept of a path should be familiar to anyone who has worked on a DOS or Unix platform. Itâ€™s an environment variable that provides an application with a list of places to look for some resource. The most common example is a path for executable programs. The Java CLASSPATH environment variable, similarly, is a list of locations that can be searched for packages containing Java class files. Both the Java interpreter and the Java compiler use CLASSPATH when searching for packages and classes on the local host. A location on the class path can be a directory name or the name of a class archive file.</p>

<p>A JAR (<strong>J</strong>ava <strong>Ar</strong>chive) file is a bundle of compiled Java code.  Java supports archives of class files in its own Java archive ( JAR) format, and in the conventional ZIP format. JAR and ZIP are really the same format, but JAR archives include extra files that describe each archiveâ€™s contents. JAR files are created with the SDKâ€™s jar utility. The archive format enables large groups of classes to be distributed in a single file; the Java interpreter automatically extracts individual class files from an archive, as needed. Once the JAR file is downloaded, all we need to do is to add it to the classpath - we can then start interacting with the classes and objects defined in the JAR.</p>

<h2 id="before-spring">Before Spring</h2>

<p>Before the Spring revolution, enterprise applications were generally written using the J2EE standards. In theory, you could deploy your application on any J2EE application server, on any platform. Running your application on an application server has several benefits, the application server offers you services, such as transaction management, messaging, mailing, a directory interface etc. Any J2EE compliant code can make use of these services, as long as the code is written against the interfaces defined in the J2EE specifications.</p>

<p>Unfortunately, there were a few problems with these standards. First of all, the usage of these standards was too complex. Writing a component (EJB: Enterprise Java Bean) required you to write a set of xml files (deployment descriptors), home interfaces, remote/local interfaces, etc. Even worse, 50% of the deployment descriptors were vendor specific, so â€˜transparently migrating an application from vendor A to Bâ€™ was suddenly not so transparent anymore.</p>

<p>Secondly, there was the â€˜look-upâ€™ problem. When a component requires another component, the components itself was responsible for looking up the components it depends upon. Unfortunately, this look-up happens by name, so the name of the dependency was hardcoded in your component.</p>

<p>Last but not least, in a lot of cases, some components did not need all the services the application server provided, but since there was no other API to build components, all your components became heavy weight, bloating your application.</p>

<h2 id="the-pojo-revolution">The POJO Revolution</h2>

<p>Coding against the J2EE standards was very cumbersome, you needed to comply to several seemingly arbitrary rules, and it forced you to write code that was not so Object Oriented as one would want to. More and more developers wanted to write just Plain Old Java Objects (POJOâ€™s), without the J2EE standards overhead.</p>

<p>Spring allows you to do programming with very simple non-Spring classes, which means there is no need to implement Spring-specific classes or interfaces, so all classes in the Spring-based application are simply POJOs. That means you can compile and run these files without dependency on Spring libraries.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span><span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(){</span>
		<span class="k">return</span> <span class="s">"Hello World"</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
The preceding class is a simple POJO class with no special indication or implementation related to the framework to make it a Spring component. So this class could function equally well in a Spring application as it could in a non-Spring application.</p>

<p>The only problem with POJOâ€™s is that with J2EE (as it existed then) you cannot benefit from the services provided by the container, such as transaction management, remoting, etc. This is where the Spring Framework comes in. This framework brings a lightweight container where your POJOâ€™s live in. You donâ€™t have to support services you donâ€™t need, this also means no unneeded configuration. You donâ€™t have to adhere to some programming model, you can just use POJOâ€™s and declaratively specify what services you want to use.</p>

<h2 id="spring-framework">Spring Framework</h2>

:ET